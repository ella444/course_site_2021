import os
import pathlib
from typing import Union, Tuple
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


class QuestionnaireAnalysis:
    Q_KEYS = ['q1', 'q2', 'q3', 'q4', 'q5']
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        self.data_fname = data_fname
        self.read_data()
        print()

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        if not os.path.exists(self.data_fname):
            raise ValueError
        try:
            self.data = pd.read_json(self.data_fname)
        except ValueError as e:
            self.data = None

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

        Returns
        -------
        hist : np.ndarray
          Number of people in a given bin
        bins : np.ndarray
          Bin edges
            """
        hist, bins = np.histogram(self.data['age'].dropna().values, bins=range(0, 110, 10),)
        # plt.hist(bins[:-1], bins, weights=hist)
        # plt.show()
        return hist.astype(float), bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

        Returns
        -------
        df : pd.DataFrame
          A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
          the (ordinal) index after a reset.
            """
        self.data.dropna()
        df = self.data[self.data['email'].notna()]
        return df[df.apply(lambda x: self.is_email_valid(x, x['email']), axis=1)]

    @staticmethod
    def is_email_valid(t, email):
        # @ appears only once
        if len(email.split('@')) != 2 or '.' not in email:
            return False
        if email.startswith('@') or email.endswith('@') or email.startswith('.') or email.endswith('.'):
            return False
        if email.split('@')[1].startswith('.'):
            return False

        return True

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
        df : pd.DataFrame
          The corrected DataFrame after insertion of the mean grade
        arr : np.ndarray
              Row indices of the students that their new grades were generated
            """
        df1 = pd.DataFrame(data=self.data)
        df = pd.DataFrame(data=self.data, columns=self.Q_KEYS)

        rows_with_nan = []
        for index, row in df.iterrows():
            is_nan_series = row.isnull()
            if is_nan_series.any():
                rows_with_nan.append(index)
                self.calc_mean(df1, index, row)

        return df1, np.asarray(rows_with_nan)

    def calc_mean(self, df1, index, row):
        q_answers = pd.Series({key: row[key] for key in self.Q_KEYS})
        if q_answers.isnull().values.any():
            nan_idxs = q_answers.loc[q_answers.isna()].index
            valid_answers_mean = q_answers[q_answers.loc[q_answers.notna()].index].mean()
            for nan_idx in nan_idxs:
                df1.loc[index, nan_idx] = valid_answers_mean

        return row


if __name__ == '__main__':
    q = QuestionnaireAnalysis('data.json')
    # hist, bins = q.show_age_distrib()
    # df = q.remove_rows_without_mail()
    df = q.fill_na_with_mean()



